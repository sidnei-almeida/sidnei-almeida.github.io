<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="index.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />
  
  <!-- Plotly.js para gráficos interativos -->
  <script src="https://cdn.plot.ly/plotly-2.25.2.min.js"></script>
  
  <!-- Adicionando um seletor de cores para facilitar a personalização -->
  <script src="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/pickr.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@simonwep/pickr/dist/themes/classic.min.css">
  
  <title>Visualização Interativa de Dados - Dashboard Analítico</title>
  <meta name="description" content="Dashboard analítico estilo Tableau para visualização interativa de dados" />
  
  <style>
    /* Estilos para o dashboard de dados */
    .dashboard-container {
      display: flex;
      flex-direction: column;
      max-width: 100%;
      margin: 0 auto;
      color: var(--white-1);
    }
    
    .dashboard-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2rem;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      padding-bottom: 1.5rem;
      position: relative;
      background: linear-gradient(90deg, rgba(50,50,50,0.3) 0%, rgba(30,30,30,0) 100%);
      border-radius: 8px 8px 0 0;
      padding: 2rem;
      margin: -1rem -1rem 2rem -1rem;
      box-shadow: 0 10px 30px -15px rgba(0,0,0,0.3);
    }
    
    .dashboard-title-container {
      position: relative;
    }
    
    .dashboard-title {
      font-size: 3.2rem;
      color: var(--white);
      position: relative;
      display: inline-block;
      margin-bottom: 0.3rem;
      font-weight: 700;
      letter-spacing: 0.5px;
      background: linear-gradient(90deg, var(--white) 0%, rgba(255,255,255,0.8) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    
    .dashboard-title-highlight {
      position: absolute;
      width: 20px;
      height: 20px;
      background: radial-gradient(circle, rgba(213,0,50,0.4) 0%, rgba(213,0,50,0) 70%);
      border-radius: 50%;
      top: 0;
      left: 0;
      filter: blur(8px);
      opacity: 0;
      animation: move-highlight 8s ease-in-out infinite;
    }
    
    @keyframes move-highlight {
      0% { left: 0; top: 10px; opacity: 0; }
      20% { opacity: 1; }
      50% { left: 100%; top: 5px; opacity: 0; }
      100% { left: 0; top: 10px; opacity: 0; }
    }
    
    .dashboard-title::after {
      content: '';
      position: absolute;
      left: 0;
      bottom: -8px;
      width: 60px;
      height: 4px;
      background: linear-gradient(90deg, var(--pink) 0%, rgba(213, 0, 50, 0.6) 100%);
      border-radius: 2px;
    }
    
    .dashboard-subtitle {
      font-size: 1.6rem;
      color: var(--white-1);
      opacity: 0.8;
      margin-top: 1.2rem;
      max-width: 600px;
      letter-spacing: 0.3px;
    }
    
    .dashboard-meta {
      display: flex;
      align-items: center;
      gap: 1.5rem;
      margin-top: 0.5rem;
    }
    
    .dashboard-meta-item {
      display: flex;
      align-items: center;
      font-size: 1.3rem;
      color: rgba(255,255,255,0.7);
      gap: 0.5rem;
    }
    
    .dashboard-meta-item i {
      color: var(--pink);
      font-size: 1.4rem;
    }
    
    .dashboard-actions {
      display: flex;
      gap: 1rem;
      align-items: center;
      background: rgba(255,255,255,0.05);
      padding: 1rem;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .connection-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 0.5rem;
    }
    
    .connection-active {
      background-color: #2ecc71;
      box-shadow: 0 0 10px rgba(46, 204, 113, 0.5);
    }
    
    .connection-warning {
      background-color: #f39c12;
      box-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
    }
    
    .connection-standby {
      background-color: #3498db;
      box-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
    }
    
    .dashboard-content {
      display: flex;
      flex-direction: row;
      width: 100%;
      gap: 1.5rem;
      min-height: 600px;
    }
    
    .sidebar {
      flex: 0 0 300px;
      background: rgba(255,255,255,0.03);
      border-radius: 8px;
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }
    
    .main-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }
    
    .chart-row {
      display: flex;
      width: 100%;
      gap: 1.5rem;
      min-height: 300px;
    }
    
    .chart-card {
      background: rgba(255,255,255,0.03);
      border-radius: 8px;
      padding: 1.5rem;
      width: 100%;
      display: flex;
      flex-direction: column;
    }
    
    .chart-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      padding-bottom: 0.5rem;
    }
    
    .chart-card-title {
      font-size: 1.6rem;
      font-weight: 500;
    }
    
    .chart-area {
      flex: 1;
      min-height: 200px;
      width: 100%;
    }
    
    /* Aumentar altura mínima para gráficos específicos */
    #distribution-chart {
      min-height: 280px;
    }
    
    .control-group {
      margin-bottom: 1.5rem;
    }
    
    .control-label {
      display: block;
      font-size: 1.4rem;
      margin-bottom: 0.5rem;
      color: var(--white-1);
    }
    
    .control-input {
      width: 100%;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      color: var(--white);
      padding: 0.8rem;
      border-radius: 4px;
      font-size: 1.4rem;
    }
    
    .control-input option {
      background: #1e1e1e;
    }
    
    .btn {
      background: var(--pink);
      color: white;
      border: none;
      padding: 1rem 2rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1.4rem;
      transition: all 0.3s;
      width: 100%;
    }
    
    .btn:hover {
      background: #b5002a;
    }
    
    .filter-section {
      margin-top: 1.5rem;
    }
    
    .filter-title {
      font-size: 1.6rem;
      margin-bottom: 1rem;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      padding-bottom: 0.5rem;
    }
    
    .filter-container {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .filter-item {
      margin-bottom: 0.5rem;
    }
    
    .data-upload {
      background: rgba(255,255,255,0.03);
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
    }
    
    .upload-title {
      font-size: 1.6rem;
      margin-bottom: 1rem;
    }
    
    .upload-area {
      border: 2px dashed rgba(255,255,255,0.2);
      border-radius: 8px;
      padding: 2rem;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .upload-area:hover {
      border-color: var(--pink);
      background: rgba(213, 0, 50, 0.05);
    }
    
    .upload-icon {
      font-size: 3rem;
      margin-bottom: 1rem;
      color: rgba(255,255,255,0.5);
    }
    
    .upload-text {
      font-size: 1.4rem;
      color: var(--white-1);
    }
    
    /* Botão Home */
    .home {
        position: fixed;
        bottom: 20px;
        left: 20px;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background-color: var(--pink);
        border: none;
        cursor: pointer;
        z-index: 9999;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .home img {
        width: 24px;
        height: 24px;
        transition: filter 0.3s ease;
    }
    .home:hover {
        background-color: transparent;
        border: 1px solid var(--pink);
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    .home:hover img {
        filter: brightness(0) saturate(100%) invert(27%) sepia(51%) saturate(2878%) hue-rotate(330deg) brightness(104%) contrast(97%);
    }
    .home:active {
        transform: scale(0.95);
        border: 1px solid var(--pink);
    }
    
    /* Notificações */
    .notification {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 1.5rem;
      background: rgba(30, 30, 30, 0.9);
      border-left: 4px solid var(--pink);
      color: var(--white);
      border-radius: 4px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
      z-index: 9999;
      font-size: 1.4rem;
      max-width: 350px;
      transition: all 0.3s;
      opacity: 0;
      transform: translateX(50px);
    }
    
    .notification.show {
      opacity: 1;
      transform: translateX(0);
    }
    
    .notification.error {
      border-left-color: #e74c3c;
    }
    
    .notification.success {
      border-left-color: #2ecc71;
    }
    
    .chart-controls {
      display: flex;
      align-items: center;
      gap: 0.8rem;
    }
    
    .chart-type-select {
      background: rgba(255,255,255,0.1);
      color: var(--white);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      padding: 0.3rem 0.6rem;
      font-size: 1.2rem;
    }
    
    .chart-type-select option {
      background: #1e1e1e;
    }
    
    /* Adicionando estilos para os novos controles de estilo e download */
    .chart-actions {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }
    
    .btn-download {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      color: var(--white);
      padding: 0.3rem 0.6rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1.2rem;
      display: flex;
      align-items: center;
      gap: 0.3rem;
    }
    
    .btn-download:hover {
      background: rgba(255,255,255,0.2);
    }
    
    .style-controls {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      padding: 1rem 0;
      border-top: 1px solid rgba(255,255,255,0.1);
      margin-top: 1rem;
    }
    
    .style-control-title {
      font-size: 1.6rem;
      margin-bottom: 0.5rem;
    }
    
    .color-picker-wrapper {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }
    
    .color-picker-label {
      font-size: 1.4rem;
      color: var(--white-1);
    }
    
    .color-picker {
      height: 2rem;
      width: 100%;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.2);
      cursor: pointer;
    }
    
    .theme-selector {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-bottom: 1rem;
    }
    
    .theme-option {
      width: 3rem;
      height: 3rem;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.2s;
    }
    
    .theme-option:hover {
      transform: scale(1.1);
    }
    
    .theme-option.active {
      border-color: var(--pink);
    }
    
    .theme-dark {
      background: linear-gradient(to bottom right, #1e1e1e, #2c3e50);
    }
    
    .theme-light {
      background: linear-gradient(to bottom right, #f5f7fa, #c3cfe2);
    }
    
    .theme-sunset {
      background: linear-gradient(to bottom right, #ff416c, #ff4b2b);
    }
    
    .theme-ocean {
      background: linear-gradient(to bottom right, #2980b9, #6dd5fa);
    }
    
    .theme-forest {
      background: linear-gradient(to bottom right, #134e5e, #71b280);
    }
    
    /* Estilos para seleção múltipla e checkboxes */
    select[multiple] {
      height: auto;
      min-height: 120px;
      padding: 0.5rem;
    }
    
    select[multiple] option {
      padding: 0.5rem;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    
    select[multiple] option:hover {
      background-color: rgba(255,255,255,0.1);
    }
    
    .checkbox-container {
      display: flex;
      align-items: center;
      position: relative;
      padding-left: 35px;
      margin-bottom: 0.5rem;
      cursor: pointer;
      font-size: 1.4rem;
      user-select: none;
      color: var(--white-1);
    }
    
    .checkbox-container input {
      position: absolute;
      opacity: 0;
      cursor: pointer;
      height: 0;
      width: 0;
    }
    
    .checkmark {
      position: absolute;
      top: 0;
      left: 0;
      height: 20px;
      width: 20px;
      background-color: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.3);
      border-radius: 3px;
    }
    
    .checkbox-container:hover input ~ .checkmark {
      background-color: rgba(255,255,255,0.2);
    }
    
    .checkbox-container input:checked ~ .checkmark {
      background-color: var(--pink);
      border-color: var(--pink);
    }
    
    .checkmark:after {
      content: "";
      position: absolute;
      display: none;
    }
    
    .checkbox-container input:checked ~ .checkmark:after {
      display: block;
    }
    
    .checkbox-container .checkmark:after {
      left: 7px;
      top: 3px;
      width: 5px;
      height: 10px;
      border: solid white;
      border-width: 0 2px 2px 0;
      transform: rotate(45deg);
    }
    
    /* Estilos para o novo componente de seleção múltipla */
    .custom-multi-select {
      width: 100%;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 4px;
      overflow: hidden;
      color: var(--white);
    }
    
    .multi-select-header {
      padding: 0.8rem;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    
    .search-input {
      width: 100%;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      color: var(--white);
      padding: 0.5rem;
      border-radius: 4px;
      font-size: 1.3rem;
    }
    
    .multi-select-actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .multi-select-btn {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      color: var(--white);
      padding: 0.4rem 0.8rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1.2rem;
      transition: all 0.2s;
    }
    
    .multi-select-btn:hover {
      background: rgba(255,255,255,0.2);
    }
    
    .selected-count {
      font-size: 1.2rem;
      color: var(--white-1);
    }
    
    .multi-select-options {
      max-height: 200px;
      overflow-y: auto;
      padding: 0.5rem;
    }
    
    .option-item {
      display: flex;
      align-items: center;
      padding: 0.6rem;
      border-radius: 3px;
      margin-bottom: 0.2rem;
      cursor: pointer;
      transition: background 0.2s;
    }
    
    .option-item:hover {
      background: rgba(255,255,255,0.1);
    }
    
    .option-item.selected {
      background: rgba(213, 0, 50, 0.2);
    }
    
    .option-checkbox {
      margin-right: 0.8rem;
      accent-color: var(--pink);
      width: 16px;
      height: 16px;
    }
    
    .option-label {
      font-size: 1.3rem;
      flex: 1;
    }
    
    .option-preview {
      color: rgba(255,255,255,0.5);
      font-size: 1.1rem;
      max-width: 80px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    /* Adicionar rolagem personalizada para o multi-select */
    .multi-select-options::-webkit-scrollbar {
      width: 8px;
    }
    
    .multi-select-options::-webkit-scrollbar-track {
      background: rgba(255,255,255,0.05);
      border-radius: 4px;
    }
    
    .multi-select-options::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.2);
      border-radius: 4px;
    }
    
    .multi-select-options::-webkit-scrollbar-thumb:hover {
      background: rgba(255,255,255,0.3);
    }
  </style>
</head>
<body>
  <button class="home" onclick="window.location.href = 'index.html'">
    <i class="fas fa-home" style="color: white; font-size: 24px;"></i>
  </button>

  <div class="dashboard-container">
    <div class="dashboard-header">
      <div class="dashboard-title-container">
        <h1 class="dashboard-title">Dashboard Analítico</h1>
        <div class="dashboard-title-highlight"></div>
      </div>
      <p class="dashboard-subtitle">Plataforma interativa para análise de dados e visualizações avançadas estilo Tableau</p>
      <div class="dashboard-meta">
        <div class="dashboard-meta-item">
          <i class="fas fa-chart-line"></i>
          <span id="dashboard-stats">0 registros analisados</span>
        </div>
        <div class="dashboard-meta-item">
          <i class="fas fa-clock"></i>
          <span id="dashboard-updated">Atualizado: <span id="last-update-time">agora</span></span>
        </div>
      </div>
      <div class="dashboard-actions">
        <div id="connection-status" class="connection-indicator connection-standby"></div>
        <span>Pronto para análise</span>
      </div>
    </div>
    
    <div class="dashboard-content">
      <!-- Sidebar com controles -->
      <div class="sidebar">
        <!-- Área de upload de dados -->
        <div class="data-upload">
          <h3 class="upload-title">Upload de Dados</h3>
          <div class="upload-area" id="upload-area">
            <div class="upload-icon">
              <i class="fas fa-cloud-upload-alt"></i>
            </div>
            <p class="upload-text">Arraste um arquivo CSV ou clique para selecionar</p>
            <input type="file" id="file-upload" accept=".csv" style="display: none">
          </div>
        </div>
        
        <!-- Controles de configuração de gráficos -->
        <div class="control-group">
          <label class="control-label" for="dataset-select">Dataset:</label>
          <select class="control-input" id="dataset-select">
            <option value="">Selecione um dataset</option>
          </select>
        </div>
        
        <div class="control-group">
          <label class="control-label" for="chart-type">Tipo de Gráfico:</label>
          <select class="control-input" id="chart-type">
            <option value="bar">Barras</option>
            <option value="line">Linha</option>
            <option value="pie">Pizza</option>
            <option value="scatter">Dispersão</option>
            <option value="area">Área</option>
            <option value="heatmap">Mapa de Calor (Correlação)</option>
          </select>
        </div>
        
        <div class="control-group">
          <label class="control-label" for="x-column">Eixo X:</label>
          <select class="control-input" id="x-column">
            <option value="">Selecione uma coluna</option>
          </select>
        </div>
        
        <!-- Substituir o seletor de eixo Y com uma interface de seleção múltipla melhorada -->
        <div class="control-group">
          <label class="control-label" for="y-column-container">Eixo Y:</label>
          <div class="custom-multi-select" id="y-column-container">
            <div class="multi-select-header">
              <input type="text" id="y-column-search" placeholder="Pesquisar variáveis..." class="search-input">
              <div class="multi-select-actions">
                <button id="select-all-y" class="multi-select-btn">Todos</button>
                <button id="clear-all-y" class="multi-select-btn">Limpar</button>
                <span id="selected-count" class="selected-count">0 selecionados</span>
              </div>
            </div>
            <div id="y-column-options" class="multi-select-options">
              <!-- As opções serão adicionadas dinamicamente aqui -->
            </div>
          </div>
          <select id="y-column" style="display: none;" multiple></select>
        </div>
        
        <div class="control-group">
          <label class="control-label" for="aggregation">Agregação:</label>
          <select class="control-input" id="aggregation">
            <option value="">Sem agregação</option>
            <option value="sum">Soma</option>
            <option value="avg">Média</option>
            <option value="count">Contagem</option>
            <option value="min">Mínimo</option>
            <option value="max">Máximo</option>
          </select>
        </div>
        
        <!-- Adicionar opções de estilo avançado -->
        <div class="control-group">
          <label class="control-label">Opções Avançadas:</label>
          <div style="display: flex; flex-direction: column; gap: 0.8rem; margin-top: 0.5rem;">
            <label class="checkbox-container">
              <input type="checkbox" id="show-trendline">
              <span class="checkmark"></span>
              Mostrar Linha de Tendência
            </label>
            
            <label class="checkbox-container">
              <input type="checkbox" id="advanced-style" checked>
              <span class="checkmark"></span>
              Estilo Profissional
            </label>
            
            <label class="checkbox-container">
              <input type="checkbox" id="show-grid" checked>
              <span class="checkmark"></span>
              Mostrar Grid
            </label>
          </div>
        </div>
        
        <!-- Adicionar controles de estilo -->
        <div class="style-controls">
          <h3 class="style-control-title">Estilo do Gráfico</h3>
          
          <div class="theme-selector">
            <div class="theme-option theme-dark active" data-theme="dark" title="Tema Escuro"></div>
            <div class="theme-option theme-light" data-theme="light" title="Tema Claro"></div>
            <div class="theme-option theme-sunset" data-theme="sunset" title="Tema Sunset"></div>
            <div class="theme-option theme-ocean" data-theme="ocean" title="Tema Ocean"></div>
            <div class="theme-option theme-forest" data-theme="forest" title="Tema Forest"></div>
          </div>
          
          <div class="color-picker-wrapper">
            <label class="color-picker-label" for="primary-color">Cor Primária:</label>
            <div id="primary-color-picker" class="color-picker"></div>
          </div>
          
          <div class="color-picker-wrapper">
            <label class="color-picker-label" for="accent-color">Cor Secundária:</label>
            <div id="accent-color-picker" class="color-picker"></div>
          </div>
        </div>
        
        <button class="btn" id="apply-btn">Aplicar Visualização</button>
        
        <!-- Área de filtros dinâmicos -->
        <div class="filter-section">
          <h3 class="filter-title">Filtros</h3>
          <div class="filter-container" id="filters">
            <!-- Filtros serão adicionados dinamicamente -->
          </div>
        </div>
      </div>
      
      <!-- Área principal com gráficos -->
      <div class="main-area">
        <!-- Primeira linha de gráficos -->
        <div class="chart-row">
          <div class="chart-card">
            <div class="chart-card-header">
              <h3 class="chart-card-title">Visualização Principal</h3>
              <div class="chart-controls">
                <select class="chart-type-select" data-target="main-chart">
                  <option value="bar">Barras</option>
                  <option value="line">Linha</option>
                  <option value="pie">Pizza</option>
                </select>
                <button class="btn-download" data-chart="main-chart"><i class="fas fa-download"></i> PNG</button>
              </div>
            </div>
            <div class="chart-area" id="main-chart"></div>
          </div>
        </div>
        
        <!-- Segunda linha de gráficos -->
        <div class="chart-row">
          <div class="chart-card">
            <div class="chart-card-header">
              <h3 class="chart-card-title">Análise de Tendências</h3>
              <div class="chart-controls">
                <select class="chart-type-select" data-target="trend-chart">
                  <option value="line">Linha</option>
                  <option value="area">Área</option>
                </select>
                <button class="btn-download" data-chart="trend-chart"><i class="fas fa-download"></i> PNG</button>
              </div>
            </div>
            <div class="chart-area" id="trend-chart"></div>
          </div>
          
          <div class="chart-card">
            <div class="chart-card-header">
              <h3 class="chart-card-title">Distribuição</h3>
              <div class="chart-controls">
                <select class="chart-type-select" data-target="distribution-chart">
                  <option value="histogram">Histograma</option>
                  <option value="bar">Barras</option>
                </select>
                <button class="btn-download" data-chart="distribution-chart"><i class="fas fa-download"></i> PNG</button>
              </div>
            </div>
            <div class="chart-area" id="distribution-chart"></div>
          </div>
        </div>
        
        <!-- Terceira linha de gráficos (novos cards) -->
        <div class="chart-row">
          <div class="chart-card">
            <div class="chart-card-header">
              <h3 class="chart-card-title">Dispersão</h3>
              <div class="chart-controls">
                <select class="chart-type-select" data-target="additional-chart1">
                  <option value="scatter">Dispersão</option>
                  <option value="heatmap">Mapa de Calor</option>
                </select>
                <button class="btn-download" data-chart="additional-chart1"><i class="fas fa-download"></i> PNG</button>
              </div>
            </div>
            <div class="chart-area" id="additional-chart1"></div>
          </div>
          
          <div class="chart-card">
            <div class="chart-card-header">
              <h3 class="chart-card-title">Proporções</h3>
              <div class="chart-controls">
                <select class="chart-type-select" data-target="additional-chart2">
                  <option value="pie">Pizza</option>
                  <option value="bar">Barras</option>
                </select>
                <button class="btn-download" data-chart="additional-chart2"><i class="fas fa-download"></i> PNG</button>
              </div>
            </div>
            <div class="chart-area" id="additional-chart2"></div>
          </div>
        </div>
        
        <!-- Quarta linha de gráficos (novos cards) -->
        <div class="chart-row">
          <div class="chart-card">
            <div class="chart-card-header">
              <h3 class="chart-card-title">Análise Temporal</h3>
              <div class="chart-controls">
                <select class="chart-type-select" data-target="temporal-chart">
                  <option value="line">Linha</option>
                  <option value="area">Área</option>
                </select>
                <button class="btn-download" data-chart="temporal-chart"><i class="fas fa-download"></i> PNG</button>
              </div>
            </div>
            <div class="chart-area" id="temporal-chart"></div>
          </div>
          
          <div class="chart-card">
            <div class="chart-card-header">
              <h3 class="chart-card-title">Distribuição Agregada</h3>
              <div class="chart-controls">
                <select class="chart-type-select" data-target="aggregated-chart">
                  <option value="bar">Barras</option>
                  <option value="histogram">Histograma</option>
                </select>
                <button class="btn-download" data-chart="aggregated-chart"><i class="fas fa-download"></i> PNG</button>
              </div>
            </div>
            <div class="chart-area" id="aggregated-chart"></div>
          </div>
        </div>
        
        <!-- Quinta linha de gráficos (novo card largo) -->
        <div class="chart-row">
          <div class="chart-card">
            <div class="chart-card-header">
              <h3 class="chart-card-title">Análise Multivariada</h3>
              <div class="chart-controls">
                <select class="chart-type-select" data-target="multivariate-chart">
                  <option value="heatmap">Mapa de Calor</option>
                  <option value="scatter3d">Gráfico 3D</option>
                </select>
                <button class="btn-download" data-chart="multivariate-chart"><i class="fas fa-download"></i> PNG</button>
              </div>
            </div>
            <div class="chart-area" id="multivariate-chart"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="notification" id="notification">
    <!-- Notificações serão adicionadas dinamicamente -->
  </div>

  <script>
    // Elementos DOM
    const datasetSelect = document.getElementById('dataset-select');
    const chartTypeSelect = document.getElementById('chart-type');
    const xColumnSelect = document.getElementById('x-column');
    const yColumnSelect = document.getElementById('y-column');
    const aggregationSelect = document.getElementById('aggregation');
    const applyBtn = document.getElementById('apply-btn');
    const mainChartContainer = document.getElementById('main-chart');
    const trendChartContainer = document.getElementById('trend-chart');
    const distributionChartContainer = document.getElementById('distribution-chart');
    const additionalChart1Container = document.getElementById('additional-chart1');
    const additionalChart2Container = document.getElementById('additional-chart2');
    const temporalChartContainer = document.getElementById('temporal-chart');
    const aggregatedChartContainer = document.getElementById('aggregated-chart');
    const multivariateChartContainer = document.getElementById('multivariate-chart');
    const filtersContainer = document.getElementById('filters');
    const uploadArea = document.getElementById('upload-area');
    const fileUpload = document.getElementById('file-upload');
    const chartTypeSelects = document.querySelectorAll('.chart-type-select');
    const downloadButtons = document.querySelectorAll('.btn-download');
    const themeOptions = document.querySelectorAll('.theme-option');
    const showTrendlineCheckbox = document.getElementById('show-trendline');
    const advancedStyleCheckbox = document.getElementById('advanced-style');
    const showGridCheckbox = document.getElementById('show-grid');
    
    // Estado da aplicação
    let currentDataset = null;
    let dataColumns = [];
    let activeFilters = {};
    let rawData = [];
    let apiBaseUrl = 'https://processamentodadosapi-production.up.railway.app';
    let apiConnected = false;
    let chartData = null; // Para armazenar os dados dos gráficos
    let selectedYColumns = []; // Para armazenar as colunas Y selecionadas
    
    // Configurações de estilo dos gráficos
    let chartStyle = {
      theme: 'dark',
      primaryColor: '#d50032',
      accentColor: '#3498db',
      fontColor: '#ddd',
      backgroundColor: 'rgba(0,0,0,0)',
      gridColor: 'rgba(255,255,255,0.1)'
    };
    
    // Temas predefinidos
    const chartThemes = {
      dark: {
        primaryColor: '#d50032',
        accentColor: '#3498db',
        fontColor: '#ddd',
        backgroundColor: 'rgba(0,0,0,0)',
        gridColor: 'rgba(255,255,255,0.1)'
      },
      light: {
        primaryColor: '#e74c3c',
        accentColor: '#3498db',
        fontColor: '#333',
        backgroundColor: '#ffffff',
        gridColor: 'rgba(0,0,0,0.1)'
      },
      sunset: {
        primaryColor: '#ff416c',
        accentColor: '#ff4b2b',
        fontColor: '#fff',
        backgroundColor: 'rgba(45,45,60,0.2)',
        gridColor: 'rgba(255,255,255,0.1)'
      },
      ocean: {
        primaryColor: '#2980b9',
        accentColor: '#6dd5fa',
        fontColor: '#fff',
        backgroundColor: 'rgba(25,50,80,0.2)',
        gridColor: 'rgba(255,255,255,0.1)'
      },
      forest: {
        primaryColor: '#134e5e',
        accentColor: '#71b280',
        fontColor: '#fff',
        backgroundColor: 'rgba(10,40,20,0.2)',
        gridColor: 'rgba(255,255,255,0.1)'
      }
    };

    // Inicialização
    document.addEventListener('DOMContentLoaded', init);
    
    // Função para mostrar notificações ao usuário
    function showNotification(message, type = 'default') {
      const notification = document.getElementById('notification');
      
      // Remover classes existentes
      notification.className = 'notification';
      
      // Adicionar classe de acordo com o tipo
      if (type === 'error') {
        notification.classList.add('error');
      } else if (type === 'success') {
        notification.classList.add('success');
      }
      
      // Definir a mensagem
      notification.textContent = message;
      
      // Mostrar a notificação
      notification.classList.add('show');
      
      // Ocultar após 4 segundos
      setTimeout(() => {
        notification.classList.remove('show');
      }, 4000);
    }
    
    // Função para configurar o drag and drop para upload de arquivos
    function setupDragAndDrop() {
      const dropArea = document.getElementById('upload-area');
      
      // Prevenir o comportamento padrão de arrastar e soltar
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropArea.addEventListener(eventName, preventDefaults, false);
        document.body.addEventListener(eventName, preventDefaults, false);
      });
      
      // Destacar a área quando o arquivo for arrastado sobre ela
      ['dragenter', 'dragover'].forEach(eventName => {
        dropArea.addEventListener(eventName, highlight, false);
      });
      
      // Remover o destaque quando o arquivo sair da área
      ['dragleave', 'drop'].forEach(eventName => {
        dropArea.addEventListener(eventName, unhighlight, false);
      });
      
      // Processar o arquivo quando for solto na área
      dropArea.addEventListener('drop', handleDrop, false);
      
      // Funções auxiliares
      function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
      }
      
      function highlight() {
        dropArea.classList.add('highlight');
      }
      
      function unhighlight() {
        dropArea.classList.remove('highlight');
      }
      
      function handleDrop(e) {
        const dt = e.dataTransfer;
        const files = dt.files;
        
        if (files.length) {
          const fileInput = document.getElementById('file-upload');
          fileInput.files = files;
          handleFileUpload({ target: { files } });
        }
      }
    }
    
    // Função para processar o upload de arquivo
    async function handleFileUpload(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      // Verificar se é um arquivo CSV
      if (!file.name.endsWith('.csv')) {
        showNotification('Por favor, selecione um arquivo CSV válido.', 'error');
        return;
      }
      
      showNotification('Processando arquivo...', 'default');
      
      try {
        if (apiConnected) {
          // Enviar para a API usando FormData
          const formData = new FormData();
          formData.append('file', file);
          
          const response = await fetch(`${apiBaseUrl}/api/upload`, {
            method: 'POST',
            body: formData
          });
          
          const result = await response.json();
          
          if (result.success) {
            showNotification('Arquivo carregado com sucesso!', 'success');
            
            // Atualizar a lista de datasets
            await loadDatasets();
            
            // Selecionar o dataset recém-carregado
            if (result.dataset) {
              datasetSelect.value = result.dataset;
              await handleDatasetChange();
            }
          } else {
            showNotification(`Erro ao processar o arquivo: ${result.error}`, 'error');
          }
        } else {
          // Processar localmente usando FileReader
          const reader = new FileReader();
          
          reader.onload = async function(e) {
            try {
              const csvData = e.target.result;
              
              // Processar CSV (parse simples por vírgulas e quebras de linha)
              const lines = csvData.split('\n');
              const headers = lines[0].split(',').map(h => h.trim());
              
              const data = [];
              for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue; // Pular linhas vazias
                
                const values = lines[i].split(',');
                const row = {};
                
                headers.forEach((header, index) => {
                  row[header] = values[index] ? values[index].trim() : '';
                });
                
                data.push(row);
              }
              
              // Salvar dados processados
              rawData = data;
              
              if (rawData.length > 0) {
                // Definir nome do dataset baseado no nome do arquivo
                const datasetName = file.name.replace('.csv', '');
                currentDataset = datasetName;
                
                // Extrair nomes das colunas
                dataColumns = Object.keys(rawData[0]);
                
                // Atualizar controles
                const option = document.createElement('option');
                option.value = datasetName;
                option.textContent = datasetName;
                
                // Limpar e adicionar o novo dataset
                datasetSelect.innerHTML = '';
                datasetSelect.appendChild(option);
                datasetSelect.value = datasetName;
                
                // Preencher selects de colunas
                populateColumnSelects();
                
                // Criar controles de filtros
                createFilterControls();
                
                // Atualizar metadados do dashboard
                updateDashboardStats(rawData);
                
                showNotification('Arquivo carregado com sucesso!', 'success');
              } else {
                showNotification('O arquivo não contém dados válidos.', 'error');
              }
            } catch (error) {
              console.error('Erro ao processar CSV:', error);
              showNotification('Erro ao processar o arquivo CSV. Verifique o formato.', 'error');
            }
          };
          
          reader.onerror = function() {
            showNotification('Erro ao ler o arquivo.', 'error');
          };
          
          reader.readAsText(file);
        }
      } catch (error) {
        console.error('Erro no upload:', error);
        showNotification('Erro ao processar o arquivo.', 'error');
      }
    }

    // Função para verificar a conexão com a API
    async function checkApiConnection() {
      try {
        const response = await fetch(`${apiBaseUrl}/api/datasets`, { 
          method: 'GET',
          timeout: 3000 // 3 segundos
        });
        
        if (response.ok) {
          apiConnected = true;
          showNotification('Conectado à API de processamento de dados', 'success');
        } else {
          apiConnected = false;
          showNotification('Problemas de conexão com a API. O processamento local será usado como fallback.', 'error');
        }
      } catch (error) {
        console.error('Erro ao conectar à API:', error);
        apiConnected = false;
        showNotification('Não foi possível conectar à API. Verifique se o servidor está rodando em localhost:8000', 'error');
      }
    }
    
    // Função para carregar a lista de datasets disponíveis
    async function loadDatasets() {
      try {
        if (!apiConnected) {
          // Se a API não estiver conectada, mostrar apenas uma opção para upload
          datasetSelect.innerHTML = '<option value="">Faça upload de um arquivo CSV</option>';
          return;
        }
        
        const response = await fetch(`${apiBaseUrl}/api/datasets`);
        const data = await response.json();
        
        // Limpar e preencher o select de datasets
        datasetSelect.innerHTML = '<option value="">Selecione um dataset</option>';
        
        data.datasets.forEach(dataset => {
          const option = document.createElement('option');
          option.value = dataset;
          option.textContent = dataset;
          datasetSelect.appendChild(option);
        });
      } catch (error) {
        console.error('Erro ao carregar datasets:', error);
        datasetSelect.innerHTML = '<option value="">Faça upload de um arquivo CSV</option>';
        showNotification('Erro ao carregar a lista de datasets da API.', 'error');
      }
    }
    
    // Função para lidar com a mudança de dataset
    async function handleDatasetChange() {
      const selectedDataset = datasetSelect.value;
      
      if (!selectedDataset) {
        resetControls();
        return;
      }
      
      try {
        // Carregar dados completos
        const response = await fetch(`${apiBaseUrl}/api/data/${selectedDataset}`);
        rawData = await response.json();
        
        if (rawData && rawData.length > 0) {
          currentDataset = selectedDataset;
          
          // Extrair nomes das colunas do primeiro registro
          dataColumns = Object.keys(rawData[0]);
          
          // Preencher selects de colunas
          populateColumnSelects();
          
          // Criar controles de filtros
          createFilterControls();
          
          // Atualizar metadados do dashboard
          updateDashboardStats(rawData);
          
          // Salvar o dataset selecionado
          localStorage.setItem('currentDataset', selectedDataset);
        } else {
          showNotification('O dataset selecionado não contém dados.', 'error');
          resetControls();
        }
      } catch (error) {
        console.error('Erro ao carregar dados do dataset:', error);
        showNotification('Erro ao carregar dados do dataset da API.', 'error');
        resetControls();
      }
    }
    
    // Função para resetar controles
    function resetControls() {
      xColumnSelect.innerHTML = '<option value="">Selecione uma coluna</option>';
      yColumnSelect.innerHTML = '<option value="">Selecione uma coluna</option>';
      filtersContainer.innerHTML = '';
      mainChartContainer.innerHTML = '';
      trendChartContainer.innerHTML = '';
      distributionChartContainer.innerHTML = '';
      additionalChart1Container.innerHTML = '';
      additionalChart2Container.innerHTML = '';
      temporalChartContainer.innerHTML = '';
      aggregatedChartContainer.innerHTML = '';
      multivariateChartContainer.innerHTML = '';
      currentDataset = null;
      dataColumns = [];
      activeFilters = {};
      rawData = [];
      
      // Limpar dados salvos
      resetSavedState();
    }
    
    // Função para resetar o localStorage
    function resetSavedState() {
      localStorage.removeItem('dashboardState');
      localStorage.removeItem('chartData');
      localStorage.removeItem('currentDataset');
      localStorage.removeItem('primaryColor');
      localStorage.removeItem('accentColor');
      localStorage.removeItem('selectedTheme');
    }
    
    // Função para carregar o estado salvo anteriormente
    async function loadSavedState() {
      try {
        // Verificar se há um estado salvo
        const savedState = localStorage.getItem('dashboardState');
        if (!savedState) return;
        
        // Parseando o estado
        const state = JSON.parse(savedState);
        
        // Verificar se o dataset salvo está disponível
        if (state.dataset) {
          // Verificar se o dataset está disponível no select
          const datasetExists = Array.from(datasetSelect.options).some(option => option.value === state.dataset);
          
          if (datasetExists) {
            // Selecionando o dataset
            datasetSelect.value = state.dataset;
            
            // Carregar os dados do dataset
            await handleDatasetChange();
            
            // Configurar os controles com os valores salvos
            if (state.xColumn && xColumnSelect.querySelector(`option[value="${state.xColumn}"]`)) {
              xColumnSelect.value = state.xColumn;
            }
            
            if (state.yColumns && Array.isArray(state.yColumns)) {
              // Restaurar seleções Y nas checkboxes
              const checkboxes = document.querySelectorAll('.option-item .option-checkbox');
              checkboxes.forEach(checkbox => {
                const value = checkbox.value;
                if (state.yColumns.includes(value)) {
                  checkbox.checked = true;
                  checkbox.closest('.option-item').classList.add('selected');
                } else {
                  checkbox.checked = false;
                  checkbox.closest('.option-item').classList.remove('selected');
                }
              });
              
              // Atualizar o array selectedYColumns
              selectedYColumns = [...state.yColumns];
              
              // Atualizar também o select oculto para compatibilidade
              for (let i = 0; i < yColumnSelect.options.length; i++) {
                const option = yColumnSelect.options[i];
                option.selected = state.yColumns.includes(option.value);
              }
              
              // Atualizar o contador
              updateSelectedCount();
            }
            
            if (state.chartType) {
              chartTypeSelect.value = state.chartType;
            }
            
            if (state.aggregation) {
              aggregationSelect.value = state.aggregation;
            }
            
            // Restaurar filtros
            if (state.filters) {
              activeFilters = state.filters;
              
              // Aplicar os valores dos filtros nos campos
              Object.entries(state.filters).forEach(([column, value]) => {
                const filterInput = document.getElementById(`filter-${column}`);
                if (filterInput) {
                  filterInput.value = value;
                }
              });
            }
            
            // Restaurar configurações de estilo
            if (state.chartStyle) {
              chartStyle = state.chartStyle;
              
              // Atualizar a interface de acordo com o tema
              themeOptions.forEach(option => {
                if (option.getAttribute('data-theme') === chartStyle.theme) {
                  option.classList.add('active');
                } else {
                  option.classList.remove('active');
                }
              });
            }
            
            // Restaurar tipos de gráficos para cada container
            if (state.chartTypeSelections) {
              Object.entries(state.chartTypeSelections).forEach(([chartId, chartType]) => {
                const select = document.querySelector(`.chart-type-select[data-target="${chartId}"]`);
                if (select && select.querySelector(`option[value="${chartType}"]`)) {
                  select.value = chartType;
                }
              });
            }
            
            // Restaurar opções avançadas
            if (showTrendlineCheckbox && state.showTrendline !== undefined) {
              showTrendlineCheckbox.checked = state.showTrendline;
            }
            
            if (advancedStyleCheckbox && state.advancedStyle !== undefined) {
              advancedStyleCheckbox.checked = state.advancedStyle;
            }
            
            if (showGridCheckbox && state.showGrid !== undefined) {
              showGridCheckbox.checked = state.showGrid;
            }
            
            // Tentar restaurar os dados dos gráficos
            const savedChartData = localStorage.getItem('chartData');
            if (savedChartData) {
              try {
                chartData = JSON.parse(savedChartData);
                
                // Renderizar os gráficos com os dados salvos
                renderAllCharts();
                
                showNotification('Estado anterior restaurado com sucesso!', 'success');
              } catch (e) {
                console.warn('Erro ao restaurar dados dos gráficos:', e);
              }
            }
          }
        }
      } catch (error) {
        console.error('Erro ao carregar estado salvo:', error);
        showNotification('Não foi possível restaurar o estado anterior.', 'error');
      }
    }

    // Função principal para renderizar os gráficos
    async function renderCharts() {
      // Verificar se há dados disponíveis
      if (!rawData || rawData.length === 0) {
        showNotification('Não há dados para visualizar. Selecione um dataset válido.', 'error');
        return;
      }
      
      // Obter valores dos controles
      const xColumn = xColumnSelect.value;
      const chartType = chartTypeSelect.value;
      const aggregation = aggregationSelect.value;
      
      // Verificar se pelo menos o eixo X e uma coluna Y foram selecionados
      if (!xColumn) {
        showNotification('Selecione uma coluna para o eixo X.', 'error');
        return;
      }
      
      if (selectedYColumns.length === 0) {
        showNotification('Selecione pelo menos uma coluna para o eixo Y.', 'error');
        return;
      }
      
      // Mostrar notificação de processamento
      showNotification('Processando dados e gerando visualizações...', 'default');
      
      try {
        // Processar os dados localmente
        const filteredData = applyFilters(rawData);
        chartData = processData(filteredData, xColumn, selectedYColumns, chartType, aggregation);
        
        // Atualizar metadados do dashboard
        updateDashboardStats(filteredData);
        
        // Salvar o estado atual no localStorage
        saveCurrentState();
        
        // Renderizar todos os gráficos
        renderAllCharts();
        
        showNotification('Visualizações geradas com sucesso!', 'success');
      } catch (error) {
        console.error('Erro ao renderizar gráficos:', error);
        showNotification('Erro ao processar dados e renderizar visualizações.', 'error');
      }
    }
    
    // Função para renderizar todos os gráficos
    function renderAllCharts() {
      // Implementação básica que será expandida conforme necessário
      if (!chartData) return;
      
      // Renderizar cada gráfico com seus respectivos dados
      renderMainChart();
      renderTrendChart();
      renderDistributionChart();
      renderAdditionalChart1();
      renderAdditionalChart2();
      renderTemporalChart();
      renderAggregatedChart();
      renderMultivariateChart();
    }
    
    // Função para renderizar o gráfico principal
    function renderMainChart() {
      if (!chartData || !chartData.main) return;
      
      const chartType = document.querySelector('.chart-type-select[data-target="main-chart"]').value;
      const data = chartData.main;
      const layout = createChartLayout('Visualização Principal');
      
      Plotly.newPlot('main-chart', data, layout, {responsive: true});
    }
    
    // Função para renderizar o gráfico de tendências
    function renderTrendChart() {
      if (!chartData || !chartData.trend) return;
      
      const chartType = document.querySelector('.chart-type-select[data-target="trend-chart"]').value;
      const data = chartData.trend;
      const layout = createChartLayout('Análise de Tendências');
      
      Plotly.newPlot('trend-chart', data, layout, {responsive: true});
    }
    
    // Função para renderizar o gráfico de distribuição
    function renderDistributionChart() {
      if (!chartData || !chartData.distribution) return;
      
      const chartType = document.querySelector('.chart-type-select[data-target="distribution-chart"]').value;
      const data = chartData.distribution;
      const layout = createChartLayout('Distribuição');
      
      Plotly.newPlot('distribution-chart', data, layout, {responsive: true});
    }
    
    // Função para renderizar o gráfico adicional 1
    function renderAdditionalChart1() {
      if (!chartData || !chartData.additional1) return;
      
      const chartType = document.querySelector('.chart-type-select[data-target="additional-chart1"]').value;
      const data = chartData.additional1;
      const layout = createChartLayout('Card Adicional 1');
      
      Plotly.newPlot('additional-chart1', data, layout, {responsive: true});
    }
    
    // Função para renderizar o gráfico adicional 2
    function renderAdditionalChart2() {
      if (!chartData || !chartData.additional2) return;
      
      const chartType = document.querySelector('.chart-type-select[data-target="additional-chart2"]').value;
      const data = chartData.additional2;
      const layout = createChartLayout('Card Adicional 2');
      
      Plotly.newPlot('additional-chart2', data, layout, {responsive: true});
    }
    
    // Função para renderizar o gráfico temporal
    function renderTemporalChart() {
      if (!chartData || !chartData.temporal) return;
      
      const chartType = document.querySelector('.chart-type-select[data-target="temporal-chart"]').value;
      const data = chartData.temporal;
      const layout = createChartLayout('Análise Temporal', chartType);
      
      Plotly.newPlot('temporal-chart', data, layout, {responsive: true});
    }
    
    // Função para renderizar o gráfico de distribuição agregada
    function renderAggregatedChart() {
      if (!chartData || !chartData.aggregated) return;
      
      const chartType = document.querySelector('.chart-type-select[data-target="aggregated-chart"]').value;
      const data = chartData.aggregated;
      const layout = createChartLayout('Distribuição Agregada', chartType);
      
      Plotly.newPlot('aggregated-chart', data, layout, {responsive: true});
    }
    
    // Função para renderizar o gráfico multivariado
    function renderMultivariateChart() {
      if (!chartData || !chartData.multivariate) return;
      
      const chartType = document.querySelector('.chart-type-select[data-target="multivariate-chart"]').value;
      const data = chartData.multivariate;
      const layout = createChartLayout('Análise Multivariada', chartType);
      
      Plotly.newPlot('multivariate-chart', data, layout, {responsive: true});
    }
    
    // Função para criar layout base para os gráficos
    function createChartLayout(title, chartType = 'bar') {
      const layout = {
        title: '', // Removendo título interno do gráfico
        font: {
          family: 'Arial, sans-serif',
          size: 12,
          color: chartStyle.fontColor
        },
        paper_bgcolor: chartStyle.backgroundColor,
        plot_bgcolor: chartStyle.backgroundColor,
        showlegend: true,
        margin: {l: 50, r: 20, t: 30, b: 50}, // Reduzindo margem superior
        xaxis: {
          gridcolor: chartStyle.gridColor,
          showgrid: showGridCheckbox.checked
        },
        yaxis: {
          gridcolor: chartStyle.gridColor,
          showgrid: showGridCheckbox.checked
        }
      };
      
      // Ajustes específicos por tipo de gráfico
      if (chartType === 'pie') {
        layout.showlegend = true;
        layout.legend = {
          orientation: "h",
          y: -0.2
        };
      } else if (chartType === 'histogram') {
        layout.bargap = 0.05;
        layout.bargroupgap = 0.2;
      } else if (chartType === 'heatmap') {
        layout.margin = {l: 80, r: 20, t: 50, b: 80};
        layout.xaxis.tickangle = -45;
      } else if (chartType === 'scatter3d') {
        // Configurar layout 3D específico
        layout.scene = {
          xaxis: {
            gridcolor: chartStyle.gridColor,
            showgrid: showGridCheckbox.checked,
            title: 'X'
          },
          yaxis: {
            gridcolor: chartStyle.gridColor,
            showgrid: showGridCheckbox.checked,
            title: 'Y'
          },
          zaxis: {
            gridcolor: chartStyle.gridColor,
            showgrid: showGridCheckbox.checked,
            title: 'Z'
          },
          camera: {
            eye: {x: 1.5, y: 1.5, z: 1.5}
          }
        };
        
        // Aumentar a altura para visualização 3D adequada
        layout.height = 600;
      } else if (title === 'Análise Multivariada') {
        // Aumentar altura para visualização multivariada
        layout.height = 600;
      }
      
      // Aplicar estilo avançado se estiver habilitado
      if (advancedStyleCheckbox.checked) {
        layout.template = {
          layout: {
            colorway: [
              chartStyle.primaryColor, 
              chartStyle.accentColor,
              adjustColor(chartStyle.primaryColor, -30),
              adjustColor(chartStyle.accentColor, -30),
              adjustColor(chartStyle.primaryColor, 30),
              adjustColor(chartStyle.accentColor, 30)
            ],
            font: {
              family: 'Arial, sans-serif'
            },
            title: {
              font: {
                family: 'Arial, sans-serif',
                size: 18,
                color: chartStyle.fontColor
              }
            },
            legend: {
              bgcolor: 'rgba(0,0,0,0)',
              bordercolor: 'rgba(0,0,0,0)',
              font: {
                family: 'Arial, sans-serif',
                size: 12,
                color: chartStyle.fontColor
              }
            }
          }
        };
      }
      
      return layout;
    }
    
    // Função auxiliar para ajustar cores (clarear ou escurecer)
    function adjustColor(color, amount) {
      // Converter para formato RGB se for hex
      let r, g, b;
      
      if (color.startsWith('#')) {
        // Formato hexadecimal
        color = color.substring(1); // Remover o #
        
        // Checar se é formato curto (3 caracteres)
        if (color.length === 3) {
          r = parseInt(color[0] + color[0], 16);
          g = parseInt(color[1] + color[1], 16);
          b = parseInt(color[2] + color[2], 16);
        } else {
          r = parseInt(color.substring(0, 2), 16);
          g = parseInt(color.substring(2, 4), 16);
          b = parseInt(color.substring(4, 6), 16);
        }
      } else if (color.startsWith('rgb')) {
        // Formato rgb() ou rgba()
        const matches = color.match(/\d+/g);
        r = parseInt(matches[0]);
        g = parseInt(matches[1]);
        b = parseInt(matches[2]);
      } else {
        // Retornar a cor original se não puder processar
        return color;
      }
      
      // Ajustar os valores
      r = Math.max(0, Math.min(255, r + amount));
      g = Math.max(0, Math.min(255, g + amount));
      b = Math.max(0, Math.min(255, b + amount));
      
      // Retornar no formato hex
      return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
    }
    
    // Função para aplicar filtros aos dados
    function applyFilters(data) {
      if (Object.keys(activeFilters).length === 0) return data;
      
      return data.filter(row => {
        let includeRow = true;
        
        for (const [column, filterValue] of Object.entries(activeFilters)) {
          if (!filterValue) continue;
          
          const rowValue = String(row[column]).toLowerCase();
          if (!rowValue.includes(String(filterValue).toLowerCase())) {
            includeRow = false;
            break;
          }
        }
        
        return includeRow;
      });
    }
    
    // Função para processar dados localmente
    function processData(data, xColumn, yColumns, chartType, aggregation) {
      // Verificar se há dados disponíveis
      if (!data || data.length === 0) {
        return null;
      }

      // Função auxiliar para aplicar agregação aos dados
      function aggregate(values, type) {
        if (!values || values.length === 0) return 0;
        
        // Converter valores para números quando possível
        const numericValues = values
          .map(v => parseFloat(v))
          .filter(v => !isNaN(v));
        
        if (numericValues.length === 0) return 0;
        
        switch (type) {
          case 'sum':
            return numericValues.reduce((sum, val) => sum + val, 0);
          case 'avg':
            return numericValues.reduce((sum, val) => sum + val, 0) / numericValues.length;
          case 'count':
            return numericValues.length;
          case 'min':
            return Math.min(...numericValues);
          case 'max':
            return Math.max(...numericValues);
          default:
            return null; // Sem agregação
        }
      }

      // Se não houver agregação, processar dados diretamente
      if (!aggregation) {
        // Preparar dados para o gráfico principal
        const mainChartData = yColumns.map(yColumn => {
          const trace = {
            x: data.map(row => row[xColumn]),
            y: data.map(row => {
              const value = row[yColumn];
              return isNaN(value) ? value : parseFloat(value);
            }),
            type: chartType,
            name: yColumn
          };
          
          // Configurações específicas por tipo de gráfico
          if (chartType === 'bar') {
            trace.marker = {
              color: chartStyle.primaryColor,
              opacity: 0.8
            };
          } else if (chartType === 'scatter') {
            trace.mode = 'markers';
            trace.marker = {
              size: 10,
              color: chartStyle.primaryColor,
              opacity: 0.7
            };
          } else if (chartType === 'line') {
            trace.mode = 'lines+markers';
            trace.line = {
              width: 3,
              color: chartStyle.primaryColor
            };
          } else if (chartType === 'area') {
            trace.type = 'scatter';
            trace.mode = 'lines';
            trace.fill = 'tozeroy';
            trace.line = {
              color: chartStyle.primaryColor
            };
          }
          
          return trace;
        });
        
        // Dados para o gráfico de tendências (usando linha por padrão)
        const trendChartData = yColumns.map(yColumn => {
          return {
            x: data.map(row => row[xColumn]),
            y: data.map(row => {
              const value = row[yColumn];
              return isNaN(value) ? value : parseFloat(value);
            }),
            type: 'line',
            mode: 'lines+markers',
            name: yColumn,
            line: {
              width: 3
            }
          };
        });
        
        // Dados para o gráfico de distribuição (histograma)
        const distributionChartData = yColumns.slice(0, 3).map(yColumn => {
          const numericValues = data
            .map(row => parseFloat(row[yColumn]))
            .filter(val => !isNaN(val));
          
          return {
            x: numericValues,
            type: 'histogram',
            name: yColumn,
            opacity: 0.7,
            marker: {
              color: yColumn === yColumns[0] ? chartStyle.primaryColor : chartStyle.accentColor
            }
          };
        });
        
        // Dados para gráfico adicional 1 (barras agrupadas)
        const additional1ChartData = yColumns.slice(0, 3).map(yColumn => {
          return {
            x: data.map(row => row[xColumn]),
            y: data.map(row => {
              const value = row[yColumn];
              return isNaN(value) ? value : parseFloat(value);
            }),
            type: 'bar',
            name: yColumn
          };
        });
        
        // Dados para gráfico adicional 2 (dispersão)
        let additional2ChartData = [];
        
        // Se houver pelo menos 2 colunas Y, criar um gráfico de dispersão
        if (yColumns.length >= 2) {
          additional2ChartData = [{
            x: data.map(row => {
              const value = row[yColumns[0]];
              return isNaN(value) ? value : parseFloat(value);
            }),
            y: data.map(row => {
              const value = row[yColumns[1]];
              return isNaN(value) ? value : parseFloat(value);
            }),
            mode: 'markers',
            type: 'scatter',
            name: `${yColumns[0]} vs ${yColumns[1]}`,
            marker: {
              size: 12,
              color: chartStyle.primaryColor,
              opacity: 0.7
            }
          }];
        } else {
          // Se não houver colunas suficientes, reutilizar dados do gráfico principal
          additional2ChartData = mainChartData;
        }
        
        return {
          main: mainChartData,
          trend: trendChartData,
          distribution: distributionChartData,
          additional1: additional1ChartData,
          additional2: additional2ChartData,
          temporal: createTemporalData(data, xColumn, yColumns),
          aggregated: createAggregatedData(data, xColumn, yColumns),
          multivariate: createMultivariateData(data, xColumn, yColumns)
        };
      } else {
        // Processar dados com agregação
        
        // Extrair valores únicos do eixo X para agrupar
        const uniqueXValues = [...new Set(data.map(row => row[xColumn]))];
        
        // Para cada valor único do eixo X, aplicar a agregação nas colunas Y
        const aggregatedData = uniqueXValues.map(xValue => {
          // Filtrar linhas que tenham o mesmo valor de X
          const rows = data.filter(row => row[xColumn] === xValue);
          
          // Objeto para armazenar resultado agregado
          const result = {
            [xColumn]: xValue
          };
          
          // Aplicar agregação para cada coluna Y
          yColumns.forEach(yColumn => {
            const values = rows.map(row => row[yColumn]);
            result[yColumn] = aggregate(values, aggregation);
          });
          
          return result;
        });
        
        // Preparar dados para o gráfico principal
        const mainChartData = yColumns.map(yColumn => {
          const trace = {
            x: aggregatedData.map(row => row[xColumn]),
            y: aggregatedData.map(row => row[yColumn]),
            type: chartType,
            name: yColumn
          };
          
          // Configurações específicas por tipo de gráfico (igual ao processamento sem agregação)
          if (chartType === 'bar') {
            trace.marker = {
              color: chartStyle.primaryColor,
              opacity: 0.8
            };
          } else if (chartType === 'scatter') {
            trace.mode = 'markers';
            trace.marker = {
              size: 10,
              color: chartStyle.primaryColor,
              opacity: 0.7
            };
          } else if (chartType === 'line') {
            trace.mode = 'lines+markers';
            trace.line = {
              width: 3,
              color: chartStyle.primaryColor
            };
          } else if (chartType === 'area') {
            trace.type = 'scatter';
            trace.mode = 'lines';
            trace.fill = 'tozeroy';
            trace.line = {
              color: chartStyle.primaryColor
            };
          }
          
          return trace;
        });
        
        // Dados para outros gráficos (similar ao processo sem agregação, mas usando dados agregados)
        const trendChartData = yColumns.map(yColumn => {
          return {
            x: aggregatedData.map(row => row[xColumn]),
            y: aggregatedData.map(row => row[yColumn]),
            type: 'line',
            mode: 'lines+markers',
            name: yColumn,
            line: {
              width: 3
            }
          };
        });
        
        const distributionChartData = yColumns.slice(0, 3).map(yColumn => {
          const numericValues = aggregatedData
            .map(row => row[yColumn])
            .filter(val => !isNaN(val));
          
          return {
            x: numericValues,
            type: 'histogram',
            name: yColumn,
            opacity: 0.7,
            marker: {
              color: yColumn === yColumns[0] ? chartStyle.primaryColor : chartStyle.accentColor
            }
          };
        });
        
        const additional1ChartData = yColumns.slice(0, 3).map(yColumn => {
          return {
            x: aggregatedData.map(row => row[xColumn]),
            y: aggregatedData.map(row => row[yColumn]),
            type: 'bar',
            name: yColumn
          };
        });
        
        let additional2ChartData = [];
        
        if (yColumns.length >= 2) {
          additional2ChartData = [{
            x: aggregatedData.map(row => row[yColumns[0]]),
            y: aggregatedData.map(row => row[yColumns[1]]),
            mode: 'markers',
            type: 'scatter',
            name: `${yColumns[0]} vs ${yColumns[1]}`,
            marker: {
              size: 12,
              color: chartStyle.primaryColor,
              opacity: 0.7
            }
          }];
        } else {
          additional2ChartData = mainChartData;
        }
        
        return {
          main: mainChartData,
          trend: trendChartData,
          distribution: distributionChartData,
          additional1: additional1ChartData,
          additional2: additional2ChartData,
          temporal: createTemporalData(aggregatedData, xColumn, yColumns),
          aggregated: createAggregatedData(aggregatedData, xColumn, yColumns),
          multivariate: createMultivariateData(aggregatedData, xColumn, yColumns)
        };
      }
    }
    
    // Função para criar dados para o gráfico temporal
    function createTemporalData(data, xColumn, yColumns) {
      // Verificar se xColumn é uma data ou tem formato numérico (para série temporal)
      const isTimeData = data.some(row => !isNaN(Date.parse(row[xColumn])));
      
      // Ordenar dados por xColumn se for temporal
      let orderedData = [...data];
      if (isTimeData) {
        orderedData.sort((a, b) => {
          const dateA = new Date(a[xColumn]);
          const dateB = new Date(b[xColumn]);
          return dateA - dateB;
        });
      } else {
        // Tentar ordenar numericamente ou alfabeticamente
        orderedData.sort((a, b) => {
          const valA = parseFloat(a[xColumn]);
          const valB = parseFloat(b[xColumn]);
          
          if (!isNaN(valA) && !isNaN(valB)) {
            return valA - valB;
          }
          return String(a[xColumn]).localeCompare(String(b[xColumn]));
        });
      }
      
      // Criar gráfico de linha para dados temporais (até 3 variáveis)
      return yColumns.slice(0, 3).map(yColumn => {
        return {
          x: orderedData.map(row => isTimeData ? new Date(row[xColumn]) : row[xColumn]),
          y: orderedData.map(row => {
            const value = row[yColumn];
            return isNaN(value) ? value : parseFloat(value);
          }),
          type: 'line',
          mode: 'lines+markers',
          name: yColumn,
          line: {
            width: 3
          }
        };
      });
    }
    
    // Função para criar dados para o gráfico de distribuição agregada
    function createAggregatedData(data, xColumn, yColumns) {
      // Calcular total e percentual para cada valor Y por categoria X
      // Ideal para gráficos de pizza ou barras empilhadas
      
      // Agrupar dados por categoria X
      const categories = {};
      
      data.forEach(row => {
        const category = row[xColumn];
        if (!categories[category]) {
          categories[category] = {};
          yColumns.forEach(col => categories[category][col] = 0);
        }
        
        // Somar valores para cada coluna Y
        yColumns.forEach(col => {
          const value = parseFloat(row[col]);
          if (!isNaN(value)) {
            categories[category][col] += value;
          }
        });
      });
      
      // Criar dados para gráfico de barras empilhadas
      const result = [];
      
      yColumns.slice(0, 5).forEach(col => { // Limitar a 5 variáveis Y para clareza
        result.push({
          x: Object.keys(categories),
          y: Object.keys(categories).map(cat => categories[cat][col]),
          type: 'bar',
          name: col
        });
      });
      
      return result;
    }
    
    // Função para criar dados para o gráfico multivariado
    function createMultivariateData(data, xColumn, yColumns) {
      // Por padrão, criar um mapa de calor de correlação
      // Se só tivermos 2-3 variáveis, criar um gráfico de dispersão 3D ou 2D
      
      if (yColumns.length >= 5) {
        // Criar matriz de correlação para mapa de calor (mais adequado para várias variáveis)
        const columnsToUse = yColumns.slice(0, 10); // Limitar a 10 colunas
        
        // Calcular a matriz de correlação
        const correlationMatrix = [];
        
        columnsToUse.forEach(column1 => {
          const correlationRow = [];
          
          columnsToUse.forEach(column2 => {
            const values1 = data.map(row => parseFloat(row[column1])).filter(val => !isNaN(val));
            const values2 = data.map(row => parseFloat(row[column2])).filter(val => !isNaN(val));
            
            // Usar o comprimento mínimo
            const minLength = Math.min(values1.length, values2.length);
            
            if (minLength === 0) {
              correlationRow.push(0);
              return;
            }
            
            const correlation = calculateCorrelation(
              values1.slice(0, minLength),
              values2.slice(0, minLength)
            );
            
            correlationRow.push(correlation);
          });
          
          correlationMatrix.push(correlationRow);
        });
        
        return [{
          z: correlationMatrix,
          x: columnsToUse,
          y: columnsToUse,
          type: 'heatmap',
          colorscale: 'RdBu',
          reversescale: true,
          zmin: -1,
          zmax: 1
        }];
      } else if (yColumns.length >= 3) {
        // Criar gráfico de dispersão 3D
        return [{
          x: data.map(row => parseFloat(row[yColumns[0]])),
          y: data.map(row => parseFloat(row[yColumns[1]])),
          z: data.map(row => parseFloat(row[yColumns[2]])),
          mode: 'markers',
          type: 'scatter3d',
          marker: {
            size: 6,
            color: data.map(row => parseFloat(row[yColumns[0]])),
            colorscale: 'Viridis',
            opacity: 0.8
          },
          name: `${yColumns[0]} vs ${yColumns[1]} vs ${yColumns[2]}`
        }];
      } else {
        // Criar gráfico de dispersão simples com tamanho de bolha
        return [{
          x: data.map(row => parseFloat(row[yColumns[0]])),
          y: data.map(row => parseFloat(row[yColumns[1] || yColumns[0]])),
          mode: 'markers',
          type: 'scatter',
          marker: {
            size: yColumns.length > 2 
              ? data.map(row => Math.abs(parseFloat(row[yColumns[2]]) * 2)) 
              : 12,
            color: chartStyle.primaryColor,
            opacity: 0.7
          },
          name: yColumns.length > 1 
            ? `${yColumns[0]} vs ${yColumns[1]}` 
            : yColumns[0]
        }];
      }
    }
    
    // Função para salvar o estado atual no localStorage
    function saveCurrentState() {
      // Coletar o estado atual de todos os controles
      const state = {
        dataset: currentDataset,
        xColumn: xColumnSelect.value,
        yColumns: selectedYColumns,
        chartType: chartTypeSelect.value,
        aggregation: aggregationSelect.value,
        filters: activeFilters,
        chartStyle: chartStyle,
        chartTypeSelections: {},
        showTrendline: showTrendlineCheckbox.checked,
        advancedStyle: advancedStyleCheckbox.checked,
        showGrid: showGridCheckbox.checked
      };
      
      // Coletar tipos de gráficos selecionados para cada container
      chartTypeSelects.forEach(select => {
        const targetChart = select.getAttribute('data-target');
        state.chartTypeSelections[targetChart] = select.value;
      });
      
      // Salvar no localStorage
      localStorage.setItem('dashboardState', JSON.stringify(state));
      
      // Salvar dados dos gráficos separadamente
      if (chartData) {
        localStorage.setItem('chartData', JSON.stringify(chartData));
      }
    }

    async function init() {
      // Verificar conexão com a API
      await checkApiConnection();
      
      // Carregar lista de datasets disponíveis
      await loadDatasets();
      
      // Carregar estado salvo anteriormente
      await loadSavedState();
      
      // Atualizar o status de conexão
      updateConnectionStatus();
      
      // Event Listeners
      datasetSelect.addEventListener('change', handleDatasetChange);
      applyBtn.addEventListener('click', renderCharts);
      uploadArea.addEventListener('click', () => fileUpload.click());
      fileUpload.addEventListener('change', handleFileUpload);
      
      // Configurar drag and drop para upload de arquivos
      setupDragAndDrop();
      
      // Configurar os event listeners para a nova interface multi-select
      setupMultiSelectInterface();
      
      // Adicionar listeners para os selects de tipo de gráfico
      chartTypeSelects.forEach(select => {
        select.addEventListener('change', handleChartTypeChange);
      });
      
      // Configurar os seletores de cores e temas
      setupStyleControls();
      
      // Configurar os botões de download
      setupDownloadButtons();
    }
    
    // Função para lidar com a mudança de tipo de gráfico
    function handleChartTypeChange(event) {
      const select = event.target;
      const targetChart = select.getAttribute('data-target');
      const selectedType = select.value;
      
      // Caso especial para o gráfico multivariado
      if (targetChart === 'multivariate-chart' && selectedType === 'scatter3d') {
        // Criar visualização 3D se tivermos pelo menos 3 variáveis Y selecionadas
        if (selectedYColumns.length >= 3) {
          const data3d = [{
            x: rawData.map(row => parseFloat(row[selectedYColumns[0]])),
            y: rawData.map(row => parseFloat(row[selectedYColumns[1]])),
            z: rawData.map(row => parseFloat(row[selectedYColumns[2]])),
            mode: 'markers',
            type: 'scatter3d',
            marker: {
              size: 6,
              color: rawData.map(row => parseFloat(row[selectedYColumns[0]])),
              colorscale: 'Viridis',
              opacity: 0.8
            },
            name: `${selectedYColumns[0]} vs ${selectedYColumns[1]} vs ${selectedYColumns[2]}`
          }];
          
          const layout = createChartLayout('Análise Multivariada', 'scatter3d');
          
          Plotly.react('multivariate-chart', data3d, layout, {responsive: true});
          
          // Salvar a seleção no estado
          saveCurrentState();
          return;
        } else {
          showNotification('São necessárias pelo menos 3 variáveis para criar um gráfico 3D.', 'error');
          
          // Resetar para o tipo anterior
          select.value = 'heatmap';
          return;
        }
      }
      
      // Se já existirem dados carregados, atualizar o gráfico com o novo tipo
      if (chartData) {
        updateChartType(targetChart, selectedType);
      }
      
      // Salvar a seleção no estado
      saveCurrentState();
    }
    
    // Função para atualizar o tipo de um gráfico específico
    function updateChartType(chartId, newType) {
      if (!chartData) return;
      
      const chart = document.getElementById(chartId);
      if (!chart) return;
      
      // Obter os dados atuais do gráfico
      let data;
      
      switch (chartId) {
        case 'main-chart':
          data = chartData.main;
          break;
        case 'trend-chart':
          data = chartData.trend;
          break;
        case 'distribution-chart':
          data = chartData.distribution;
          break;
        case 'additional-chart1':
          data = chartData.additional1;
          break;
        case 'additional-chart2':
          data = chartData.additional2;
          break;
        case 'temporal-chart':
          data = chartData.temporal;
          break;
        case 'aggregated-chart':
          data = chartData.aggregated;
          break;
        case 'multivariate-chart':
          data = chartData.multivariate;
          break;
        default:
          return;
      }
      
      if (!data) return;
      
      // Caso especial para o mapa de calor (correlação)
      if (newType === 'heatmap') {
        // Gerar matriz de correlação
        const correlationMatrix = generateCorrelationMatrix(chartId);
        Plotly.newPlot(chartId, correlationMatrix.data, correlationMatrix.layout, {responsive: true});
        return;
      }
      
      // Caso especial para gráfico 3D
      if (newType === 'scatter3d' && selectedYColumns.length >= 3) {
        const data3d = [{
          x: rawData.map(row => parseFloat(row[selectedYColumns[0]])),
          y: rawData.map(row => parseFloat(row[selectedYColumns[1]])),
          z: rawData.map(row => parseFloat(row[selectedYColumns[2]])),
          mode: 'markers',
          type: 'scatter3d',
          marker: {
            size: 6,
            color: rawData.map(row => parseFloat(row[selectedYColumns[0]])),
            colorscale: 'Viridis',
            opacity: 0.8
          },
          name: `${selectedYColumns[0]} vs ${selectedYColumns[1]} vs ${selectedYColumns[2]}`
        }];
        
        const layout = createChartLayout('Análise Multivariada', 'scatter3d');
        
        Plotly.react(chartId, data3d, layout, {responsive: true});
        return;
      }
      
      // Atualizar o tipo de cada trace no gráfico
      const updatedData = data.map(trace => {
        const newTrace = {...trace};
        
        // Ajustes específicos para cada tipo de gráfico
        if (newType === 'bar') {
          newTrace.type = 'bar';
          newTrace.mode = undefined;
          newTrace.fill = undefined;
          newTrace.marker = {
            color: chartStyle.primaryColor,
            opacity: 0.8
          };
        } else if (newType === 'line') {
          newTrace.type = 'scatter';
          newTrace.mode = 'lines+markers';
          newTrace.fill = undefined;
          newTrace.line = {
            width: 3,
            color: chartStyle.primaryColor
          };
        } else if (newType === 'scatter') {
          newTrace.type = 'scatter';
          newTrace.mode = 'markers';
          newTrace.fill = undefined;
          newTrace.marker = {
            size: 10,
            color: chartStyle.primaryColor,
            opacity: 0.7
          };
        } else if (newType === 'area') {
          newTrace.type = 'scatter';
          newTrace.mode = 'lines';
          newTrace.fill = 'tozeroy';
          newTrace.line = {
            color: chartStyle.primaryColor
          };
        } else if (newType === 'pie') {
          // Para gráfico de pizza, é preciso reformatar completamente os dados
          newTrace.type = 'pie';
          newTrace.labels = trace.x;
          newTrace.values = trace.y;
          newTrace.x = undefined;
          newTrace.y = undefined;
          newTrace.mode = undefined;
          newTrace.fill = undefined;
        } else if (newType === 'histogram') {
          newTrace.type = 'histogram';
          newTrace.x = trace.y; // Usar valores Y para o histograma
          newTrace.y = undefined;
          newTrace.mode = undefined;
          newTrace.fill = undefined;
        } else {
          newTrace.type = newType;
        }
        
        return newTrace;
      });
      
      // Atualizar o layout com base no novo tipo
      const layout = createChartLayout(
        chartId.replace('-chart', '').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
        newType
      );
      
      // Renderizar o gráfico atualizado
      Plotly.newPlot(chartId, updatedData, layout, {responsive: true});
      
      // Se o checkbox de mostrar linha de tendência estiver marcado e for um gráfico adequado
      if (showTrendlineCheckbox.checked && (newType === 'scatter' || newType === 'line')) {
        addTrendlines(chartId);
      }
    }
    
    // Função para gerar matriz de correlação para mapas de calor
    function generateCorrelationMatrix(chartId) {
      // Obter as colunas selecionadas
      const columnsToUse = selectedYColumns.length > 0 ? selectedYColumns : dataColumns.filter(col => {
        // Considerar apenas colunas numéricas
        if (rawData.length === 0) return false;
        return !isNaN(parseFloat(rawData[0][col]));
      }).slice(0, 10); // Limitar a 10 colunas para evitar sobrecarga
      
      // Calcular a matriz de correlação
      const correlationMatrix = [];
      const labels = [];
      
      // Para cada coluna, calcular a correlação com as outras
      columnsToUse.forEach(column1 => {
        const correlationRow = [];
        labels.push(column1);
        
        columnsToUse.forEach(column2 => {
          const values1 = rawData.map(row => parseFloat(row[column1])).filter(val => !isNaN(val));
          const values2 = rawData.map(row => parseFloat(row[column2])).filter(val => !isNaN(val));
          
          // Usar o mínimo de valores para garantir que os arrays tenham o mesmo tamanho
          const minLength = Math.min(values1.length, values2.length);
          
          if (minLength === 0) {
            correlationRow.push(0); // Sem correlação se não houver dados
            return;
          }
          
          // Calcular a correlação de Pearson
          const correlation = calculateCorrelation(
            values1.slice(0, minLength),
            values2.slice(0, minLength)
          );
          
          correlationRow.push(correlation);
        });
        
        correlationMatrix.push(correlationRow);
      });
      
      // Criar dados para o mapa de calor
      const data = [{
        z: correlationMatrix,
        x: labels,
        y: labels,
        type: 'heatmap',
        colorscale: 'RdBu',
        reversescale: true,
        zmin: -1,
        zmax: 1,
        showscale: true,
        colorbar: {
          title: 'Correlação',
          titleside: 'right'
        }
      }];
      
      // Criar layout para o mapa de calor
      const layout = {
        title: '', // Removendo título do mapa de calor
        font: {
          family: 'Arial, sans-serif',
          size: 12,
          color: chartStyle.fontColor
        },
        paper_bgcolor: chartStyle.backgroundColor,
        plot_bgcolor: chartStyle.backgroundColor,
        margin: {l: 80, r: 20, t: 30, b: 80}, // Reduzindo margem superior
        xaxis: {
          tickangle: -45
        }
      };
      
      return { data, layout };
    }
    
    // Função auxiliar para calcular correlação de Pearson
    function calculateCorrelation(array1, array2) {
      if (array1.length !== array2.length) {
        throw new Error('Arrays devem ter o mesmo tamanho');
      }
      
      const n = array1.length;
      
      // Calcular médias
      const mean1 = array1.reduce((sum, val) => sum + val, 0) / n;
      const mean2 = array2.reduce((sum, val) => sum + val, 0) / n;
      
      // Calcular desvios e produtos
      let sumXY = 0;
      let sumX2 = 0;
      let sumY2 = 0;
      
      for (let i = 0; i < n; i++) {
        const x = array1[i] - mean1;
        const y = array2[i] - mean2;
        
        sumXY += x * y;
        sumX2 += x * x;
        sumY2 += y * y;
      }
      
      // Calcular coeficiente de correlação
      if (sumX2 === 0 || sumY2 === 0) return 0;
      return sumXY / Math.sqrt(sumX2 * sumY2);
    }
    
    // Função para configurar a interface de seleção múltipla
    function setupMultiSelectInterface() {
      const optionsContainer = document.getElementById('y-column-options');
      const searchInput = document.getElementById('y-column-search');
      const selectAllBtn = document.getElementById('select-all-y');
      const clearAllBtn = document.getElementById('clear-all-y');
      
      // Adicionar listeners para os botões
      selectAllBtn.addEventListener('click', () => {
        const options = document.querySelectorAll('.option-item:not(.hidden) .option-checkbox');
        options.forEach(checkbox => {
          checkbox.checked = true;
          checkbox.closest('.option-item').classList.add('selected');
        });
        updateSelectedColumns();
      });
      
      clearAllBtn.addEventListener('click', () => {
        const options = document.querySelectorAll('.option-item .option-checkbox');
        options.forEach(checkbox => {
          checkbox.checked = false;
          checkbox.closest('.option-item').classList.remove('selected');
        });
        updateSelectedColumns();
      });
      
      // Adicionar listener para a pesquisa
      searchInput.addEventListener('input', () => {
        const searchTerm = searchInput.value.toLowerCase();
        const options = document.querySelectorAll('.option-item');
        
        options.forEach(option => {
          const text = option.querySelector('.option-label').textContent.toLowerCase();
          if (text.includes(searchTerm)) {
            option.classList.remove('hidden');
          } else {
            option.classList.add('hidden');
          }
        });
      });
      
      // Função para popular opções com base nas colunas disponíveis
      function populateOptions() {
        if (!dataColumns || dataColumns.length === 0) return;
        
        // Limpar opções anteriores
        optionsContainer.innerHTML = '';
        
        // Agrupar colunas por tipo (numérico, data, categórico)
        const numericColumns = [];
        const dateColumns = [];
        const categoricalColumns = [];
        
        // Análise simples de tipos
        dataColumns.forEach(column => {
          if (column === xColumnSelect.value) return; // Não incluir a coluna X
          
          // Verificar o tipo dos dados na primeira linha
          const firstValue = rawData[0][column];
          
          if (!isNaN(parseFloat(firstValue))) {
            numericColumns.push(column);
          } else if (isDate(firstValue)) {
            dateColumns.push(column);
          } else {
            categoricalColumns.push(column);
          }
        });
        
        // Função auxiliar para verificar datas
        function isDate(value) {
          return !isNaN(Date.parse(value));
        }
        
        // Adicionar grupos de opções
        if (numericColumns.length > 0) {
          addGroupHeader('Variáveis Numéricas');
          numericColumns.forEach(column => addOption(column, 'Num'));
        }
        
        if (dateColumns.length > 0) {
          addGroupHeader('Variáveis de Data');
          dateColumns.forEach(column => addOption(column, 'Data'));
        }
        
        if (categoricalColumns.length > 0) {
          addGroupHeader('Variáveis Categóricas');
          categoricalColumns.forEach(column => addOption(column, 'Cat'));
        }
        
        // Adicionar opção ao select oculto para compatibilidade
        yColumnSelect.innerHTML = '';
        dataColumns.forEach(column => {
          if (column !== xColumnSelect.value) {
            const option = document.createElement('option');
            option.value = column;
            option.textContent = column;
            yColumnSelect.appendChild(option);
          }
        });
      }
      
      // Função para adicionar cabeçalhos de grupo
      function addGroupHeader(title) {
        const header = document.createElement('div');
        header.className = 'option-group-header';
        header.style.padding = '5px';
        header.style.fontWeight = 'bold';
        header.style.borderBottom = '1px solid rgba(255,255,255,0.1)';
        header.style.marginTop = '5px';
        header.style.marginBottom = '5px';
        header.textContent = title;
        optionsContainer.appendChild(header);
      }
      
      // Função para adicionar opção
      function addOption(column, type) {
        // Obter uma prévia dos dados
        const previewValues = rawData.slice(0, 3).map(row => row[column]);
        const preview = previewValues.join(', ').substring(0, 20) + (previewValues.join(', ').length > 20 ? '...' : '');
        
        // Criar elemento de opção
        const option = document.createElement('div');
        option.className = 'option-item';
        
        // Criar checkbox
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'option-checkbox';
        checkbox.value = column;
        checkbox.addEventListener('change', () => {
          if (checkbox.checked) {
            option.classList.add('selected');
          } else {
            option.classList.remove('selected');
          }
          updateSelectedColumns();
        });
        
        // Criar label
        const label = document.createElement('span');
        label.className = 'option-label';
        label.textContent = column;
        
        // Criar preview
        const previewSpan = document.createElement('span');
        previewSpan.className = 'option-preview';
        previewSpan.textContent = type + ': ' + preview;
        
        // Montar opção
        option.appendChild(checkbox);
        option.appendChild(label);
        option.appendChild(previewSpan);
        
        // Adicionar ao container
        optionsContainer.appendChild(option);
        
        // Adicionar evento de clique para a linha inteira
        option.addEventListener('click', (e) => {
          if (e.target !== checkbox) {
            checkbox.checked = !checkbox.checked;
            
            if (checkbox.checked) {
              option.classList.add('selected');
            } else {
              option.classList.remove('selected');
            }
            
            updateSelectedColumns();
          }
        });
      }
      
      // Função para atualizar o array com as colunas selecionadas
      function updateSelectedColumns() {
        const checkboxes = document.querySelectorAll('.option-item .option-checkbox:checked');
        selectedYColumns = Array.from(checkboxes).map(cb => cb.value);
        
        // Atualizar também o select oculto para compatibilidade
        for (let i = 0; i < yColumnSelect.options.length; i++) {
          const option = yColumnSelect.options[i];
          option.selected = selectedYColumns.includes(option.value);
        }
        
        // Atualizar o contador
        updateSelectedCount();
      }
    }
    
    // Função para atualizar o contador de seleções
    function updateSelectedCount() {
      const countElement = document.getElementById('selected-count');
      const count = selectedYColumns.length;
      countElement.textContent = `${count} selecionado${count !== 1 ? 's' : ''}`;
    }
    
    // Função para popular os selects de colunas
    function populateColumnSelects() {
      if (!dataColumns || dataColumns.length === 0) return;
      
      // Limpar selects
      xColumnSelect.innerHTML = '<option value="">Selecione uma coluna</option>';
      
      // Adicionar opções para o eixo X
      dataColumns.forEach(column => {
        const option = document.createElement('option');
        option.value = column;
        option.textContent = column;
        xColumnSelect.appendChild(option);
      });
      
      // Povoar a interface de seleção múltipla para o eixo Y
      setupMultiSelectInterface();
      document.querySelector('div[id="y-column-options"]').innerHTML = '';
      
      // Analisar e agrupar colunas por tipo
      const numericColumns = [];
      const dateColumns = [];
      const categoricalColumns = [];
      
      dataColumns.forEach(column => {
        // Verificar o tipo dos dados na primeira linha
        if (rawData.length === 0) return;
        
        const firstValue = rawData[0][column];
        
        if (!isNaN(parseFloat(firstValue))) {
          numericColumns.push({ column, type: 'Num' });
        } else if (!isNaN(Date.parse(firstValue))) {
          dateColumns.push({ column, type: 'Data' });
        } else {
          categoricalColumns.push({ column, type: 'Cat' });
        }
      });
      
      // Criar grupos no container de opções Y
      const yColumnOptions = document.getElementById('y-column-options');
      
      // Função para adicionar cabeçalho de grupo
      function addGroupHeader(title) {
        const header = document.createElement('div');
        header.className = 'option-group-header';
        header.style.padding = '5px';
        header.style.fontWeight = 'bold';
        header.style.borderBottom = '1px solid rgba(255,255,255,0.1)';
        header.style.marginTop = '5px';
        header.style.marginBottom = '5px';
        header.textContent = title;
        yColumnOptions.appendChild(header);
      }
      
      // Função para adicionar opção
      function addOption(column, type) {
        // Obter uma prévia dos dados
        const previewValues = rawData.slice(0, 3).map(row => row[column]);
        const preview = previewValues.join(', ').substring(0, 20) + (previewValues.join(', ').length > 20 ? '...' : '');
        
        // Criar elemento de opção
        const option = document.createElement('div');
        option.className = 'option-item';
        
        // Criar checkbox
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'option-checkbox';
        checkbox.value = column;
        checkbox.addEventListener('change', () => {
          if (checkbox.checked) {
            option.classList.add('selected');
          } else {
            option.classList.remove('selected');
          }
          
          // Atualizar array de colunas selecionadas
          updateSelectedYColumns();
        });
        
        // Criar label
        const label = document.createElement('span');
        label.className = 'option-label';
        label.textContent = column;
        
        // Criar preview
        const previewSpan = document.createElement('span');
        previewSpan.className = 'option-preview';
        previewSpan.textContent = type + ': ' + preview;
        
        // Montar opção
        option.appendChild(checkbox);
        option.appendChild(label);
        option.appendChild(previewSpan);
        
        // Adicionar ao container
        yColumnOptions.appendChild(option);
        
        // Adicionar evento de clique para a linha inteira
        option.addEventListener('click', (e) => {
          if (e.target !== checkbox) {
            checkbox.checked = !checkbox.checked;
            
            if (checkbox.checked) {
              option.classList.add('selected');
            } else {
              option.classList.remove('selected');
            }
            
            // Atualizar array de colunas selecionadas
            updateSelectedYColumns();
          }
        });
      }
      
      // Adicionar grupos de variáveis
      if (numericColumns.length > 0) {
        addGroupHeader('Variáveis Numéricas');
        numericColumns.forEach(item => addOption(item.column, item.type));
      }
      
      if (dateColumns.length > 0) {
        addGroupHeader('Variáveis de Data');
        dateColumns.forEach(item => addOption(item.column, item.type));
      }
      
      if (categoricalColumns.length > 0) {
        addGroupHeader('Variáveis Categóricas');
        categoricalColumns.forEach(item => addOption(item.column, item.type));
      }
      
      // Função para atualizar o array com as colunas Y selecionadas
      function updateSelectedYColumns() {
        const checkboxes = document.querySelectorAll('.option-item .option-checkbox:checked');
        selectedYColumns = Array.from(checkboxes).map(cb => cb.value);
        
        // Atualizar o contador de selecionados
        const countElement = document.getElementById('selected-count');
        countElement.textContent = `${selectedYColumns.length} selecionado${selectedYColumns.length !== 1 ? 's' : ''}`;
      }
    }
    
    // Função para criar controles de filtros
    function createFilterControls() {
      // Limpar container de filtros
      filtersContainer.innerHTML = '';
      
      // Se não houver colunas de dados, sair
      if (!dataColumns || dataColumns.length === 0) return;
      
      // Criar controles de filtro para cada coluna (até 5 para não sobrecarregar a interface)
      const maxFilters = 5;
      const columnsToFilter = dataColumns.slice(0, maxFilters);
      
      columnsToFilter.forEach(column => {
        // Criar container para o filtro
        const filterItem = document.createElement('div');
        filterItem.className = 'filter-item';
        
        // Criar label
        const filterLabel = document.createElement('label');
        filterLabel.textContent = `${column}:`;
        filterLabel.style.display = 'block';
        filterLabel.style.marginBottom = '0.3rem';
        filterLabel.style.fontSize = '1.2rem';
        
        // Criar input
        const filterInput = document.createElement('input');
        filterInput.type = 'text';
        filterInput.className = 'control-input';
        filterInput.id = `filter-${column}`;
        filterInput.placeholder = `Filtrar por ${column}...`;
        filterInput.style.fontSize = '1.2rem';
        filterInput.style.padding = '0.5rem';
        
        // Adicionar evento de input para atualizar filtros
        filterInput.addEventListener('input', (e) => {
          const value = e.target.value.trim();
          
          if (value) {
            activeFilters[column] = value;
          } else {
            delete activeFilters[column];
          }
        });
        
        // Montar o item de filtro
        filterItem.appendChild(filterLabel);
        filterItem.appendChild(filterInput);
        
        // Adicionar ao container
        filtersContainer.appendChild(filterItem);
        
        // Se houver um valor de filtro salvo, aplicá-lo
        if (activeFilters[column]) {
          filterInput.value = activeFilters[column];
        }
      });
      
      // Adicionar botão para aplicar filtros
      const applyFilterBtn = document.createElement('button');
      applyFilterBtn.className = 'btn';
      applyFilterBtn.textContent = 'Aplicar Filtros';
      applyFilterBtn.style.marginTop = '1rem';
      
      applyFilterBtn.addEventListener('click', () => {
        renderCharts();
      });
      
      // Adicionar botão para limpar filtros
      const clearFilterBtn = document.createElement('button');
      clearFilterBtn.className = 'btn';
      clearFilterBtn.textContent = 'Limpar Filtros';
      clearFilterBtn.style.marginTop = '0.5rem';
      clearFilterBtn.style.background = 'rgba(255,255,255,0.1)';
      
      clearFilterBtn.addEventListener('click', () => {
        // Limpar todos os inputs de filtro
        document.querySelectorAll('.filter-item input').forEach(input => {
          input.value = '';
        });
        
        // Limpar objeto de filtros ativos
        activeFilters = {};
        
        // Renderizar novamente se houver dados
        if (chartData) {
          renderCharts();
        }
      });
      
      // Adicionar os botões ao container
      filtersContainer.appendChild(applyFilterBtn);
      filtersContainer.appendChild(clearFilterBtn);
    }
    
    // Função para configurar os seletores de estilo
    function setupStyleControls() {
      // Configurar as opções de tema
      themeOptions.forEach(option => {
        option.addEventListener('click', () => {
          // Remover a classe 'active' de todas as opções
          themeOptions.forEach(opt => opt.classList.remove('active'));
          
          // Adicionar a classe 'active' à opção selecionada
          option.classList.add('active');
          
          // Aplicar o tema selecionado
          const themeName = option.getAttribute('data-theme');
          applyTheme(themeName);
          
          // Salvar a seleção
          localStorage.setItem('selectedTheme', themeName);
        });
      });
      
      // Configurar o color picker para a cor primária
      const primaryPickr = Pickr.create({
        el: '#primary-color-picker',
        theme: 'classic',
        default: chartStyle.primaryColor,
        swatches: [
          'rgba(213, 0, 50, 1)',
          'rgba(52, 152, 219, 1)',
          'rgba(46, 204, 113, 1)',
          'rgba(241, 196, 15, 1)',
          'rgba(231, 76, 60, 1)',
          'rgba(155, 89, 182, 1)'
        ],
        components: {
          preview: true,
          opacity: true,
          hue: true,
          interaction: {
            hex: true,
            rgba: true,
            hsla: false,
            input: true,
            clear: false,
            save: true
          }
        }
      });
      
      primaryPickr.on('save', (color) => {
        const colorValue = color.toHEXA().toString();
        chartStyle.primaryColor = colorValue;
        localStorage.setItem('primaryColor', colorValue);
        
        // Se houver dados carregados, aplicar o estilo atualizado
        if (chartData) {
          updateChartsStyle();
        }
        
        primaryPickr.hide();
      });
      
      // Configurar o color picker para a cor secundária
      const accentPickr = Pickr.create({
        el: '#accent-color-picker',
        theme: 'classic',
        default: chartStyle.accentColor,
        swatches: [
          'rgba(52, 152, 219, 1)',
          'rgba(46, 204, 113, 1)',
          'rgba(241, 196, 15, 1)',
          'rgba(231, 76, 60, 1)',
          'rgba(155, 89, 182, 1)',
          'rgba(26, 188, 156, 1)'
        ],
        components: {
          preview: true,
          opacity: true,
          hue: true,
          interaction: {
            hex: true,
            rgba: true,
            hsla: false,
            input: true,
            clear: false,
            save: true
          }
        }
      });
      
      accentPickr.on('save', (color) => {
        const colorValue = color.toHEXA().toString();
        chartStyle.accentColor = colorValue;
        localStorage.setItem('accentColor', colorValue);
        
        // Se houver dados carregados, aplicar o estilo atualizado
        if (chartData) {
          updateChartsStyle();
        }
        
        accentPickr.hide();
      });
      
      // Adicionar listeners para os checkboxes de estilo
      showTrendlineCheckbox.addEventListener('change', () => {
        if (chartData) {
          updateChartsStyle();
        }
      });
      
      advancedStyleCheckbox.addEventListener('change', () => {
        if (chartData) {
          updateChartsStyle();
        }
      });
      
      showGridCheckbox.addEventListener('change', () => {
        if (chartData) {
          updateChartsStyle();
        }
      });
      
      // Carregar cores salvas do localStorage
      const savedPrimaryColor = localStorage.getItem('primaryColor');
      if (savedPrimaryColor) {
        chartStyle.primaryColor = savedPrimaryColor;
        primaryPickr.setColor(savedPrimaryColor);
      }
      
      const savedAccentColor = localStorage.getItem('accentColor');
      if (savedAccentColor) {
        chartStyle.accentColor = savedAccentColor;
        accentPickr.setColor(savedAccentColor);
      }
    }
    
    // Função para aplicar um tema
    function applyTheme(themeName) {
      if (chartThemes[themeName]) {
        // Atualizar o objeto de estilo com os valores do tema
        chartStyle = { ...chartThemes[themeName] };
        
        // Se houver dados carregados, atualizar os gráficos
        if (chartData) {
          updateChartsStyle();
        }
      }
    }
    
    // Função para atualizar o estilo dos gráficos
    function updateChartsStyle() {
      // Atualizar cada gráfico
      updateChartStyle('main-chart');
      updateChartStyle('trend-chart');
      updateChartStyle('distribution-chart');
      updateChartStyle('additional-chart1');
      updateChartStyle('additional-chart2');
      updateChartStyle('temporal-chart');
      updateChartStyle('aggregated-chart');
      updateChartStyle('multivariate-chart');
    }
    
    // Função para atualizar o estilo de um gráfico específico
    function updateChartStyle(chartId) {
      const chart = document.getElementById(chartId);
      if (!chart) return;
      
      // Obter o tipo atual do gráfico
      const chartTypeSelect = document.querySelector(`.chart-type-select[data-target="${chartId}"]`);
      const chartType = chartTypeSelect ? chartTypeSelect.value : 'bar';
      
      // Criar um layout com o estilo atualizado
      const layout = createChartLayout(
        chartId.replace('-chart', '').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
        chartType
      );
      
      // Caso especial para gráficos 3D
      if (chartId === 'multivariate-chart' && chartType === 'scatter3d') {
        // Para gráficos 3D, precisamos refazer o gráfico inteiro
        const existingData = Plotly.d3.select(`#${chartId}`).data();
        Plotly.react(chartId, existingData, layout, {responsive: true});
        return;
      }
      
      // Se for um mapa de calor, aplicar uma atualização específica
      if (chartType === 'heatmap') {
        // Gerar novos dados de correlação com o estilo atualizado
        const correlationMatrix = generateCorrelationMatrix(chartId);
        Plotly.react(chartId, correlationMatrix.data, correlationMatrix.layout, {responsive: true});
        return;
      }
      
      // Atualizar as cores e estilos das séries
      const update = {
        layout: layout
      };
      
      // Obter os traces atuais
      const chartData = Plotly.d3.select(`#${chartId}`).data();
      
      // Atualizar as cores dos traces
      if (chartData && chartData.length > 0) {
        update.marker = chartData.map((_, i) => {
          const isFirstSeries = i === 0;
          return {
            color: isFirstSeries ? chartStyle.primaryColor : chartStyle.accentColor,
            opacity: 0.8
          };
        });
        
        // Adicionar linha de tendência se necessário
        if (showTrendlineCheckbox.checked && (chartType === 'scatter' || chartType === 'line')) {
          addTrendlines(chartId);
        }
      }
      
      // Aplicar as atualizações
      Plotly.update(chartId, update);
    }
    
    // Função para adicionar linhas de tendência
    function addTrendlines(chartId) {
      const chartDiv = document.getElementById(chartId);
      if (!chartDiv) return;
      
      const existingData = Plotly.d3.select(`#${chartId}`).data();
      if (!existingData || existingData.length === 0) return;
      
      // Para cada série de dados, calcular e adicionar uma linha de tendência
      const trendlineData = [];
      
      existingData.forEach((trace, index) => {
        if (trace.x && trace.y && trace.type !== 'trendline' && 
            (trace.type === 'scatter' || trace.type === 'bar')) {
          
          // Extrair valores X e Y
          const xValues = trace.x;
          const yValues = trace.y;
          
          // Verificar se temos valores válidos para calcular a linha de tendência
          if (!xValues || !yValues || xValues.length < 2 || yValues.length < 2) return;
          
          // Calcular valores para regressão linear
          const n = xValues.length;
          let sumX = 0;
          let sumY = 0;
          let sumXY = 0;
          let sumX2 = 0;
          
          for (let i = 0; i < n; i++) {
            // Converter para números
            const x = typeof xValues[i] === 'number' ? xValues[i] : i;
            const y = typeof yValues[i] === 'number' ? yValues[i] : parseFloat(yValues[i]);
            
            if (isNaN(y)) continue;
            
            sumX += x;
            sumY += y;
            sumXY += x * y;
            sumX2 += x * x;
          }
          
          // Calcular coeficientes de regressão linear (y = a + bx)
          const b = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
          const a = (sumY - b * sumX) / n;
          
          // Criar valores para a linha de tendência
          const minX = Math.min(...xValues.filter(x => typeof x === 'number'));
          const maxX = Math.max(...xValues.filter(x => typeof x === 'number'));
          
          // Se minX e maxX forem válidos, criar a linha de tendência
          if (!isNaN(minX) && !isNaN(maxX)) {
            const trendlineX = [minX, maxX];
            const trendlineY = [a + b * minX, a + b * maxX];
            
            trendlineData.push({
              x: trendlineX,
              y: trendlineY,
              mode: 'lines',
              type: 'scatter',
              name: `Tendência ${trace.name}`,
              line: {
                color: trace.marker ? trace.marker.color : chartStyle.accentColor,
                width: 2,
                dash: 'dash'
              },
              showlegend: true,
              legendgroup: trace.name,
              opacity: 0.8,
              trendline: true
            });
          }
        }
      });
      
      // Adicionar as linhas de tendência ao gráfico
      if (trendlineData.length > 0) {
        Plotly.addTraces(chartId, trendlineData);
      }
    }
    
    // Função para configurar os botões de download de gráficos
    function setupDownloadButtons() {
      downloadButtons.forEach(button => {
        button.addEventListener('click', () => {
          const chartId = button.getAttribute('data-chart');
          const chart = document.getElementById(chartId);
          
          if (chart) {
            // Baixar como PNG
            Plotly.toImage(chart, {format: 'png', width: 1200, height: 800})
              .then(function(url) {
                const link = document.createElement('a');
                link.download = `${chartId}-${new Date().toISOString().slice(0,10)}.png`;
                link.href = url;
                link.click();
              })
              .catch(function(error) {
                console.error('Erro ao exportar gráfico:', error);
                showNotification('Erro ao exportar o gráfico como imagem.', 'error');
              });
          }
        });
      });
    }
    
    // Função para atualizar as estatísticas do dashboard
    function updateDashboardStats(data) {
      // Atualizar contagem de registros
      const statsElement = document.getElementById('dashboard-stats');
      if (statsElement && data) {
        statsElement.textContent = `${data.length.toLocaleString()} registros analisados`;
      }
      
      // Atualizar timestamp
      const lastUpdateElement = document.getElementById('last-update-time');
      if (lastUpdateElement) {
        const now = new Date();
        const timeOptions = { hour: '2-digit', minute: '2-digit' };
        lastUpdateElement.textContent = now.toLocaleTimeString(undefined, timeOptions);
      }
      
      // Atualizar status da conexão
      updateConnectionStatus();
    }
    
    // Função para atualizar o status de conexão
    function updateConnectionStatus() {
      const connectionElement = document.getElementById('connection-status');
      const statusTextElement = connectionElement ? connectionElement.nextElementSibling : null;
      if (!connectionElement || !statusTextElement) return;
      
      // Remover todas as classes de estado
      connectionElement.className = 'connection-indicator';
      
      if (apiConnected) {
        connectionElement.classList.add('connection-active');
        statusTextElement.textContent = 'API Conectada';
      } else if (rawData && rawData.length > 0) {
        connectionElement.classList.add('connection-warning');
        statusTextElement.textContent = 'Processamento Local';
      } else {
        connectionElement.classList.add('connection-standby');
        statusTextElement.textContent = 'Pronto para Análise';
      }
    }
  </script>
</body>
</html>
